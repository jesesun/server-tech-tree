# 性能指标

# 高并发线程模型
* java静态指定线程池
* golang动态分配M（工作线程）
* 线程模型：从共享内存，逐渐发展到Actor，Go routine

# 高性能架构
ppc和tpc
reactor和proactor


# 异步IO框架
* 代表：Netty

# 压测工具
* 代表：Jmeter

# 缓存
* 穿透、击穿、雪崩

# gc垃圾回收

# 边缘计算

# 数据传输
* 5G
* netty
* 数据传输格式协议：hession

# 数据存储
## 存储引擎的速度分级
* L1 cache reference：0.5ns
* Branch mispredict：5ns
* L2 cache reference：7ns
* Mutex lock/unlock：25ns
* Main memory reference：100ns
* Compress 1K bytes with Zippy：3 000ns
* Send 2K bytes over 1Gbps network：20 000ns
* Read 1MB sequentially from Memory：250 000ns
* Round trip within same datacenter：500 000ns(0.5ms)
* Disk seek：10 000 000ns(10ms)
* Read 1MB sequentially from disk：20 000 000ns(20ms)
* Send package CA->Netherlands->CA：150 000 000ns(150ms)
* 对于15000转/分钟的磁盘，寻道时间大概在2-8毫秒之间。而旋转延时平均在2毫米左右。

## Redis性能
* 数据包控制在1000字节以下，不开启pipeline吞吐量约为6w/s，使用pipeline约为10w/s。1000字节是redis性能的分水岭

## 磁盘
* 我们知道千兆网卡的最大传输速率是每秒 125MB，这样的速率和 CPU 内存固然没法比，而虽然比单个磁盘快一些，但是服务器磁盘是 8 块磁盘组成的阵列，总的磁盘吞吐量依然碾压千兆网卡，因此网卡传输速率的瓶颈就成为整个系统的性能瓶颈

## 分布式数据库
* 分库分表
    * 分别以商品ID和用户ID存储成两个表，支持不同维度的查询


# CPU
## CPU亲和力
* spark可以配置每个应用可使用的总集群和单机executor进程最大数量，即每个应用最多可以使用几个进程来分片执行。当然，进程数最好别配置超过cpu核数
* k8s：cpuset功能，即cpu亲和力，将容器分配到固定CPU减少切换，nginx也有，这是性能优化双刃剑，要求进程少于核数
